# Data Wrangling

<hr>

<div style = "float:right; width:45%;">
<img src="visuals/badge-data-wrangling.png" alt="badge-data-wrangling">  
</div>  

The information relevant for our analysis goals is not always directly accessible. Sometimes we must first uncover it effortfully from an inconvenient representation. Also, sometimes data must be cleaned (ideally: by *a priori* specified criteria) by removing data points that are deemed of insufficient quality for a particular goal. All of this, and more, is the domain of **data wrangling**: preprocessing, cleaning, reshaping, renaming etc. Section \@ref(Chap-02-02-data-IO) describes how to read data from and write data to files. Section \@ref(Chap-02-02-data-tidy-data) introduces the concept of **tidy data**. We then look at a few common tricks of data manipulation in Section \@ref(Chap-02-02-data-preprocessing-cleaning). We will learn about grouping operations in Section \@ref(Chap-02-02-data-grouping-nesting) Finally, we look at a concrete application in Section \@ref(Chap-02-02-data-case-study-KoF).

```{block, type='infobox'}
The learning goals for this chapter are:

- be able to read from and write data to files
- understand notion of *tidy data*
- be able to solve common problems of data preprocessing and cleaning
```


## Data in, data out {#Chap-02-02-data-IO}

Reading a data set from a file:

```{r, eval = F}
fresh_raw_data <- read_csv("PATH/FILENAME_RAW_DATA.csv")
```

Writing to a csv file:

<!-- TODO: mention reproducible workflow -->

```{r, eval = F}
write_csv(processed_data, "PATH/FILENAME_PROCESSED_DATA.csv")
```


## Tidy data {#Chap-02-02-data-tidy-data}

The same data can be represented in multiple ways. There is even room for variance in the class of rectangular representations of data. Some manners of representations are more useful for certain purposes than for others. For data analysis (plotting, statistical analyses) we prefer to represent our data as (rectangular) **tidy data**.

### Running example

Consider the example of student grades for two exams in a course. A compact way of representing the data for visual digestion is the following representation:


```{r , echo = T}
exam_results_visual <- tribble(
  ~exam,       ~"Rozz",   ~"Andrew",   ~"Siouxsie",
  "midterm",   "1.3",     "2.0",       "1.7",
  "final"  ,   "2.3",     "1.7",       "1.0"
)
exam_results_visual
```

This is how such data would frequently be represented, e.g., in tables in a journal. Indeed, Rmarkdown helps us present this data in an appetizing manner, e.g., in Table \@ref(tab:Ch-02-01-exam-results-untidy), which is produced by the code below:

```{r Ch-02-01-exam-results-untidy}
knitr::kable(
  exam_results_visual,
  caption = "Fictitious exam results of fictitious students.", 
  booktabs = TRUE
)
```


Though highly perspicuous, this representation of the data is not tidy, in the special technical sense we endorse here. A tidy representation of the course results could be this:


```{r}
exam_results_tidy <- tribble(
  ~student,    ~exam,      ~grade,
  "Rozz",      "midterm",  1.3,
  "Andrew",    "midterm",  2.0,
  "Siouxsie",  "midterm",  1.7,
  "Rozz",      "final",    2.3,
  "Andrew",    "final",    1.7,
  "Siouxsie",  "final",    1.0
)
exam_results_tidy
```

### Definition of *tidy data*

Following @Wickham2014:Tidy-Data, a tidy representation of (rectangular) data is defined as one where:

1. each variable forms a column,
2. each observation forms a row, and
3. each type of observational unit forms a table.

Any data set that is not tidy is **messy data**. Messy data that satisfies the first two contraints, but not the third will be called **almost tidy data** in this course. We will work, wherever possible, with data that is at least almost tidy. Figure \@ref(fig:02-02-tidy-data-picture) shows a graphical representation of the concept of tidy data.

```{r 02-02-tidy-data-picture, echo = F, fig.cap="Organization of tidy data (taken from @wickham2016)."}
knitr::include_graphics("visuals/tidy-data-R4DS.png")
```

### Excursion: non-redundant data

The final condition in the definition of tidy data is not particularly important for us here (since we will make do with 'almost tidy data'), but to understand it nonetheless consider the following data set:

```{r}
exam_results_overloaded <- tribble(
  ~student,    ~stu_number,    ~exam,      ~grade,
  "Rozz",      "666",          "midterm",  1.3,
  "Andrew",    "1969",         "midterm",  2.0,
  "Siouxsie",  "3.14",         "midterm",  1.7,
  "Rozz",      "666",          "final",    2.3,
  "Andrew",    "1969",         "final",    1.7,
  "Siouxsie",  "3.14",         "final",    1.0
)
exam_results_overloaded
```

This table is not tidy in an intuitive sense because it includes redundancy. Why list the student numbers twice, once with each observation of exam score? The table is not tidy in the technical sense that not every observational unit forms a table, i.e., the observation of student numbers and the observation of exam scores should be stored independently in different tables, like so:

```{r}
# same as before
exam_results_tidy <- tribble(
  ~student,    ~exam,      ~grade,
  "Rozz",      "midterm",  1.3,
  "Andrew",    "midterm",  2.0,
  "Siouxsie",  "midterm",  1.7,
  "Rozz",      "final",    2.3,
  "Andrew",    "final",    1.7,
  "Siouxsie",  "final",    1.0
)
# additional table with student numbers
student_numbers <- tribble(
  ~student,    ~student_number,
  "Rozz",      "666",   
  "Andrew",    "1969",
  "Siouxsie",  "3.14"
)
```

Notice that, although the information is distributed over two tibbles, it is linked by the common column `student`. If we really need to bring all of the information together, the tidyverse has a quick and elegant solution:

```{r}
full_join(exam_results_tidy, student_numbers, by = "student")
```


## Data manipulation: the basics {#Chap-02-02-data-preprocessing-cleaning}

### Pivoting

The tidyverse strongly encourages the use of tidy data, or at least almost tidy data. If your data is (almost) tidy, you can be reasonably sure that you can plot and analyze the data without additional wrangling. If your data is not (almost) tidy because it is too wide or too long (see below), what is required is a joyful round of pivoting. There are two directions of pivoting: making data longer, and making data wider.

#### Making too wide data longer with `pivot_longer`

Consider the previous example of messy data again:

```{r}
exam_results_visual <- tribble(
  ~exam,       ~"Rozz",   ~"Andrew",   ~"Siouxsie",
  "midterm",   "1.3",     "2.0",       "1.7",
  "final"  ,   "2.3",     "1.7",       "1.0"
)
exam_results_visual
```

This data is "too wide". We can make it longer with the function `pivot_longer` from the `tidyr` package. Check out the example below before we plunge into a description of `pivot_longer`.

```{r}
exam_results_visual %>% 
  pivot_longer(
    # pivot every column except the first 
    cols = - 1,
    # name of new column which contains the
    # names of the columns to be "gathered"
    names_to = "student",
    # name of new column which contains the values
    # of the cells which now form a new column
    values_to = "grade"
  ) %>% 
  # optional reordering of columns (to make 
  # the output exactly like `exam_results_tidy`)
  select(student, exam, grade)
```

What `pivot_longer` does, in general, is take a bunch of columns and gather the values of all cells in these columns into a single, new column, the so-called *value column*, i.e., the column with the values of the cells to be gathered. If `pivot_longer` stopped here, we would loose information about which cell values belonged to which original column. Therefore, `pivot_longer` also creates a second new column, the so-called *name column*, i.e., the column with the names of the original columns that we gathered together. Consequently, in order to do its job, `pivot_longer` minimally needs three pieces of information:^[There are alternative possibilities for specifying names of the value and name column, which allow for more dynamic construction of strings. We will not cover all of these details here, but we will use some of these alternative specifications in subsequent examples.]

1. which columns to spin around (function argument `cols`)
2. the name of the to-be-created new value column (function argument `values_to`)
3. the name of the to-be-created new name column (function argument `names_to`)

#### Making too long data wider with `pivot_wider`

Consider the following example of data which untidy because it is too long:

```{r}
mixed_results_too_long <- 
  tibble(student = rep(c('Rozz', 'Andrew', 'Siouxsie'), times = 2),
         what =    rep(c('grade', 'participation'), each = 3),
         howmuch = c(2.7, 2.0, 1.0, 75, 93, 33))
mixed_results_too_long
```

This data is untidy because it lumps two types of different measurements (a course grade, and the percentage of participation) in a single column. These are different variables, and so should be represented in different columns.

To fix a data representation that is too long, we can make it wider with the help of the `pivot_wider` function from the `tidyr` package. We look at an example before looking at the general behavior of the `pivot_wider` function.

```{r}
mixed_results_too_long %>% 
  pivot_wider(
    # column containing the names of the new columns
    names_from = what,
    # column containing the values of the new columns
    values_from = howmuch
  )
```

In general, `pivot_wider` picks out two columns, one column of values to distribute into new to-be-created columns, and one vector of names or groups which contains the information about the, well, names of the to-be-created new columns. There are more refined options for `pivot_wider` some of which we will encounter in the context of concrete cases of application.

### Subsetting columns and rows

If a data set contains too much information for your current purposes, you can discard irrelevant (or unhelpful) rows and columns. The function `filter` takes a Boolean expression and returns only those rows of which the Boolean expression is true:

```{r}
exam_results_tidy %>% 
  # show only entries with grades better than 1.7
  filter(grade <= 1.7)
```

The function `select` allows to pick out a subset of columns. Interestingly, it can also be used to reorder columns, because the order in which column names are specified matches the order in the returned tibble.

```{r}
exam_results_tidy %>% 
  select(grade, exam)
```

#### Tidy selection of column names

To select the colums in several functions within the tidyverse, such as `pivot_longer` or `select`, there are useful helper functions from the `tidyselect` package. Here are some examples:^[The helpers from the `tidyselect` package also accept regular expressions.]

```{r, eval = F}
# bogus code for illustration of possibilities!
SOME_DATA %>% 
  select( ... # could be one of the following
        # all columns indexed 2, 3, ..., 10
        2:10
        # all columns except the one called "COLNAME"
        - COLNAME
        # all columns with names starting with "STRING"
       ... starts_with("STRING")
       # all columns with names ending with "STRING"
       ... ends_with("STRING")
       # all columns with names containing "STRING"
       ... contains("STRING")
       # all columns with names of the form "Col_i" with i = 1, ..., 10
       ... num_range("Col_", 1:10)
  )
```



### Adding, changing and renaming columns

`mutate`, `rename`


## Grouped operations {#Chap-02-02-data-grouping-nesting}

## Case study: the King of France {#Chap-02-02-data-case-study-KoF}
