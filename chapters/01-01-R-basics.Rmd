# Basics of R {#Chap-01-01-R}

R is a specialized programming language for data science. Though old, it is heavily supported by an active community. New tools for data handling, visualization, and statistical analysis are provided in the form of **packages**.^[Packages live in the official package repository [CRAN](https://cran.r-project.org/), or are supplied in less standardized forms, e.g., via open repositories, such as GitHub.] While other programming languages specialized for scientific computing, like Python of Julia, also lend themselves beautifully for data analysis, the choice of R in this course is motivated because R's raison d'Ãªtre is data analysis. Some of the R packages that this course will use provide cutting-edge methods which are not as conveniently available in other programming languages (yet).

In a manner of speaking, there are two flavors of R. We should distinguish **base R** from the **tidyverse**. Base R is what you have when you do not load any packages. We enter the tidyverse by loading the package `tidyverse` (see below for information on how to do that). The tidyverse consists of several components (which are actually stand-alone packages that can be loaded separately if needed) all of which supply extra functionality for data analysis, based on a unifying philosophy and representation format. While eventually interchangable, the look-and-feel of base R and the tidyverse is quite different. Figure \@ref(fig:01-00-tidyverse-overview) lists a selection of packages from the tidyverse in relation to their role at different stages of the process of data analysis. The image is taken from [this introduction to the tidyverse](https://rviews.rstudio.com/2017/06/08/what-is-the-tidyverse/).


```{r 01-00-tidyverse-overview, echo = F, fig.cap="Overview of selected packages from the tidyverse."}
knitr::include_graphics("visuals/tidyverse_overview.png")
```


Make sure to have completely installed everything of relevance for this course, as described in Section \@ref(Chap-01-00-intro-installation). Unless you have strong opinions or an unassailable favorite, we recommend trying [RStudio](https://rstudio.com) as an IDE for R.

The official documentation for base R is [An Introduction to R](https://colinfay.me/intro-to-r/). The standard reference for using the tidyverse is [R for Data Science (R4DS)](https://r4ds.had.co.nz). There are some very useful [cheat sheets](https://rstudio.com/resources/cheatsheets/) which you should definitely check out! There are pointers to further material in Appendix \@ref(app-90-02-reading-material).

```{block, type='infobox'}
The learning goals for this chapter are:

- become familiar with R, its syntax and basic notions
- become familiar with the key functionality from the tidyverse
- understand and write simple R scripts
- be able to write documents in Rmarkdown
```


## First steps {#ch1-first-steps}

R is an interpreted language. This means that you do not have to compile it. You can just evaluate it line by line, in a so-called **session**. The session stores the current values of all variables. If you do not want to retype, you can store your code in a **script**.

Try this out by either typing `r` to open an R session in a terminal or load RStudio.^[When starting a session in a terminal, you can exit a running R session by typing `quit()` or `q()`.] You can immediately calculate stuff:

```{r}
6 * 7
```

### Functions

R has many built-in functions. The most common situation is that the function is called by its name using **prefix notation**, followed by round brackets which enclose the function's arguments (separated by commata if multiple). For example, the function `round` takes a number and, per default, returns the closest integer:

```{r}
## the function `round` takes a number as argument and 
## returns the closest integer (default)
round(0.6)
```

Actually, `round` allows several arguments. It takes as input the number `x` to be rounded, and another integer number `digits` which gives the number of digits after the comma to which `x` should be rounded. We can then specify these arguments in a function call of `round` by providing the named arguments.

```{r}
## rounds the number `x` to the number `digits` of digits
round(x = 0.138, digits = 2)
```

When providing all arguments with names, the order of arguments does not matter. When providing at least one non-named argument, all non-named arguments have to be presented in the right order (as expected by the function; to find out what that is use `help`, as explained below in \@ref(Chap-01-01-R-help)) after subtracting the named arguments from the ordered list of arguments.

<!-- EXERCISE: validate what's written here with a function that takes at least three named arguments -->

```{r, eval = FALSE}
round(x = 0.138, digits = 2)  # works as intended
round(digits = 2, x = 0.138)  # works as intended
round(0.138, digits = 2)      # works as intended
round(0.138, 2)               # works as intended
round(x = 0.138, 2)           # works as intended
round(digits = 2, 0.138)      # works as intended
round(2, x = 0.138)           # works as intended
round(2, 0.138)               # does not work as intended (returns 2)
```

Functions can have default values for some or all of their arguments. In the case of `round` the default is `digits = 0`. There is obviously no default for `x` in the function `round`.

Some functions can take an arbitrary number of arguments. The function `sum`, which sums up numbers is a point in case.

```{r}
## adds all of its arguments together
sum(1,2,3)
```

Selected functions can also be called in **infix notation**. This applies to frequently recurring operations, such as mathematical operations or logical comparisons.

```{r, eval = F}
## both of these calls sum 1, 2, and 3 together
sum(1,2,3)     # prefix notation
1 + 2 + 3      # prefix notation
```

Section \@ref(Chap-01-01-functions) will list some of the most important built-in functions. It will also explain how to define your own functions.

### Variables

You can assign values to variables using three assignment operators: `->`, `<-` and `=`, like so:

```{r}
x <- 6
7 -> y
z = 3
x * y / z
```

Use of `=` is discouraged.^[You can produce `<-` in RStudio with Option-`-` (on Mac) and Alt-`-` (on Windows/Linux). For other useful keyboard shortcuts, see [here](https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts).]

It is good practice to use a consistent naming scheme for variables. This book uses `snake_case_variable_names` and tends towards using `long_and_excessively_informative_names` for important variables, and short variable names, like `i`, `j` or `x`, for local variables, indices etc.


### Literate coding

It is good practice to document code with short but informative comments. Comments in R are demarcated with `#`.

```{r}
x <- 4711 # a nice number from Cologne
```

In RStudio, you can use `Command+Shift+C` (on Mac) and `Ctrl+Shift+C` (on Windows/Linux) to comment or uncomment code, and you can use comments to structure your scripts. Any comment followed by `----` is treated as a (foldable) section.

```{r, eval = FALSE}
# SECTION: variable assignments ----
x <- 6
y <- 7
# SECTION: some calculations ----
x * y
```

### Objects

Strictly speaking, all entities in R are *objects* but that is not always apparent or important for everyday practical purposes (see the manual for more information)[https://colinfay.me/intro-to-r/objects-their-modes-and-attributes.html]. R supports an object-oriented programming style, but we will not make (explicit) use of this functionality. In fact, this course heavily uses and encourages a functional programming style (see Section \@ref(ch-01-01-loops-and-maps)).

Some functions (e.g., optimizers or fitting functions for statistical models) return objects, however, and we will use this output in various ways. For example, if we run a linear regression model on some data set, the output is an object.

```{r}
## you do not need to understand this code
model_fit = lm(formula = speed~dist, data = cars)
## just notice that the function `lm` returns an object
is.object(model_fit)
## printing an object on the screen usually gives you summary information
print(model_fit)
```

### Packages

Much of R's charm unfolds through the use of packages. [CRAN](https://cran.r-project.org) has the official package repository. To install a new package from a CRAN mirror use the `install.packages` function. For example, to install the package `devtools`, you would use:

```{r, eval = FALSE}
install.packages("devtools")
```

Once installed, you need to load your desired packages for each fresh session, using:

```{r, eval = FALSE}
library(devtools)
```

Once loaded all functions, data etc. that ship with a package are available without additional reference to the package name. If you want to be careful or curteous to an admirer of your code, you can reference the package a function comes from explicitly. For example, the following code calls the function `install_github` from the package `devtools` explicitly (so that you would not need to load the package beforehand, for example):

```{r, eval = F}
devtools::install_github("SOME-URL")
```

Indeed, the `install_github` function allows you to install bleeding-edge packages from github. You can install all of the relevant packages using (after installing the `devtools` package, as described in Section \@ref(Chap-01-00-intro-installation):

```{r, eval = F}
devtools::install_github("n-kall/IDA2019-package")
```

After this installation, you can load all packages for this course simply by using:

```{r, eval = FALSE}
library(IDA2019)
```


### Getting help {#Chap-01-01-R-help}

If you encounter a function like `lm` that you do not know about, you can access its documentation with the `help` function or just typing `?lm`. Ror example, the following call summons the documentation for `lm`, the first parts are shown in Figure \@ref(fig:R-doc-example).

```{r, eval = FALSE}
help(lm)
```

```{r R-doc-example, fig.cap = "Excerpt from the documentation of the `lm` function."}
knitr::include_graphics("visuals/R-doc-example.png")
```

If you are looking for help on a more general topic, use the function `help.search`. It takes a regular expression as input and outputs a list of occurrences in the available documentation. For example, calling the following code might produce a display like in Figure \@(fig:R-doc-search-example).

```{r, eval = FALSE}
help.search("linear")
```


```{r R-doc-search-example, fig.cap = "Result of calling `help.search` for the term 'linear'."}
knitr::include_graphics("visuals/R-doc-search-example.png")
```

The top entries in Figure \@(fig:R-doc-search-example) are **vignettes**. These are compact manuals or tutorial on particular topics or functions, and they are directly available in R. If you want to browse through the vignettes available on your machine (which depend on which packages you have installed), go ahead:

```{r, eval = FALSE}
browseVignettes()
```


## Data types {#ch1-data-types}

Let's briefly go through the data types that are most important for our later purposes. We can assess the type of an object stored in variable `x` with the function `typeof(x)`. 

```{r}
typeof(3)        ## returns type "double"
typeof(TRUE)     ## returns type "logical"
typeof(cars)     ## returns 'list' (includes data.frames, tibbles, objects, ...)
typeof("huhu")   ## return 'character" (= string) 
typeof(mean)     ## return 'closure" (= function)
typeof(c)        ## return 'builtin" (= deep system internal stuff)
typeof(round)    ## returns type "special" (= well, special stuff?)
```

It is sometimes possible to cast objects of one type into another type `XXX` using functions `as.XXX` in base R or `as_XXX` in the tidyverse.

```{r}
## casting Boolean value `TRUE` into number format 
as.numeric(TRUE)
```

R is essentially an array-based language. Arrays are arbitrary but finite dimensional matrices. We will discuss what is usually referred to as vectors (= one-dimensional arrays), matrices (= two-dimensional arrays) and arrays (= more-than-two-dimensional) in the following section on numeric information. But it is important to keep in mind that arrays can contain objects of other types than numeric information (as long as all objects in the array are of the same type).

### Numeric vectors & matrices

#### Numeric information

Standard number format in R is double. 

```{r}
typeof(3)
```

We can also represent numbers as integers and complex.

```{r}
typeof(as.integer(3))    # returns 'integer'
typeof(as.complex(3))    # returns 'complex'
```

#### Numeric vectors

As a generally useful heuristic, expect every numerical information to be treated as a vector (or higher-order: matrix, array, ... ; see below), and to expect any (basic, mathematical) operation in R to (most likely) apply to the whole vector, matrix, array, collection.^[If you are familiar with Python's *scipy* and *numpy* packages, this is R's default mode of treating numerical information.] This makes it possible to ask for the length of a variable to which we assing a single number, for instance:

```{r}
x <- 7
length(x)
```

We can even index such a variable:

```{r}
x <- 7
x[1]     ## what is the entry in position 1 of the vector x?
```

Or assign a new value to a hitherto unused index:

```{r}
x[3] <- 6   ## assign the value 6 to the 3rd entry of vector x
x           ## notice that the 2nd entry is undefined, or "NA", not available
```

Vectors in general can be declared with the built-in function `c()`. To memorize this, think of *concatenation* or *combination*.

```{r}
x <- c(4, 7, 1, 1)   # this is now a 4-place vector
x
```

There are also helpful functions to generate sequences of numbers:

```{r, eval = F}
1:10                                     ## returns 1, 2, 3, ..., 10
seq(from = 1, to = 10, by = 1)           ## returns 1, 2, 3, ..., 10
seq(from = 1, to = 10, by = 0.5)         ## returns 1, 1.5, 2, ..., 9.5, 10
seq(from = 0, to = 1 , length.out = 11)  ## returns 0, 0.1, ..., 0.9, 1
```

Indexing in R starts with 1, not 0!

```{r}
x <- c(4, 7, 1, 1)   # this is now a 4-place vector
x[2]
```

And now we see what is meant above when we said that (almost) every mathematical operation can be expected to apply to a vector:

```{r}
x <- c(4, 7, 1, 1)   # 4-placed vector as before
x + 1
```

#### Numeric matrices

Matrices are declared with the function `matrix`. This function takes, for instance, a vector as an argument.

```{r}
x <- c(4, 7, 1, 1)     # 4-placed vector as before
(m <- matrix(x))       # cast x into matrix format
```

Notice that the result is a matrix with a single column. This is important. R uses so-called *column-major mode*.^[Python, on the other hand, uses the reverse *row-major mode*.] This means that it will fill columns first. For example, a matrix with three columns based on a six-placed vector $1, 2, \dots, 6$ will be built by filling the first column from top to bottom, then the second column top to bottom, and so on.^[It is in this sense that the "first index moves fastest" in column-major mode, which is another frequently given explanation of column-major mode.]

```{r}
m <- matrix(1:6, ncol = 3)
m
```

In line with column-major mode, vectors are treated as column vectors in matrix operations:

```{r}
x = c(1,0,1)   ## 3-place vector
m %*% x        ## dot product with previous matrix 'm'
```

As usual, and independently of column- or row-major mode, matrix indexing starts with the row index:

```{r}
m[1,]   ## produces first row of matrix 'm'
```

#### Arrays

Arrays are simply higher-dimensional matrices. We will not make use of arrays in this course.

#### Names for vectors, matrices and arrays

The positions in a vector can be given names. This is extremely useful for good "literate coding" and therefore highly recommended. The names of vector `x`'s positions are retrieved and set by the `names` function:

```{r}
students <- c("Jax", "Jamie", "Jason")  # names of students
grades <- c(1.3, 2.7, 2.0)              # a vector of grades
names(grades)                           # retrieve names: with no nanmes so far
names(grades) <- students               # assign names
names(grades)                           # retrieve names again: names assigned
grades                                  # output shows names
```

We can also set the names of a vector directly during construction:

```{r}
# names of students
students <- c("Jax", "Jamie", "Jason")  
# constructing a vector with names directly assigned
grades <- c(1.3, 2.7, 2.0, names = students) 
```


Names for matrices are retrieved or set with functions `rownames` and `colnames`.

```{r}
m <- matrix(1:6, ncol = 3)  ## declare matrix
rownames(m) <-paste0("row_", 1:nrow(m))
colnames(m) <-paste0("col_", 1:ncol(m))
m
```

### Booleans

There are built-in names for Boolean values "true" and "false", predictably named `TRUE` and `FALSE`. Equivalent shortcuts are `T` and `F`. If we attempt to do math with Boolean vectors, the outcome is what any reasonable logician would expect:

```{r}
x = c(T,F,T)
1 - x
x + 3
```

Boolean vectors can be used as index sets to extract elements from other vectors.

```{r}
number_vector  = 1:5           # 1, 2, ..., 5
boolean_vector = c(T,F,T,F,T)  # index of odd numbers set to `TRUE`
number_vector[boolean_vector]  # returns the elemnts from number vector, for which
                               # the corresponding element in the Boolean vector is true
```

### Special values

There are a couple of keywords reserved in R for special kinds of objects:

- `NA`: "not availables"; represents missing values in data
- `NaN`: "not a number"; e.g., division zero by zero
- `Inf` or `-Inf`: infinity and negative infinity; returned when number is too big or devision by zero
- `NULL`: the NULL object; often returned when function is undefined for input

### Characters (= strings)

- strings are called characters

```{r}
typeof("huhu")
```

- `paste`, `grep`, `cat`, `sprintf`... what else?

- vector of characters

```{r}
chr.vector = c("huhu", "hello", "huhu", "ciao")
chr.vector
```

### Factors

- factors track levels

```{r}
factor(chr.vector)
```

- ordered factors arrange their levels

```{r}
factor(chr.vector, ordered = T,
       levels = c("huhu", "ciao", "hello"))
```

### Lists, data frames & tibbles

- lists are key-value pairs

```{r}
my_list = list(dudu = 1,
               chacha = c("huhu", "ciao"))
```

- data frames as lists of same-length vectors

```{r}
exp_data = data.frame(
  trial = 1:5,
  condition = factor(c("C1", "C2", "C1", "C3", "C2"),
                     ordered = T),
              response = c(121, 133, 119, 102, 156))
exp_data
```

- access columns

```{r}
exp_data$condition
```

- access rows

```{r}
exp_data[3,]
```

- tibbles are data frames in the tidyverse

```{r}
as_tibble(exp_data)
```

- tibbles do but data frames don't allow for dynamic construction:

- some differences

```{r, eval = FALSE}
my_tibble    = tibble(x = 1:10, y = x^2)      ## dynamic construction possible
my_dataframe = data.frame(x = 1:10, y = x^2)  ## ERROR :/
```

## Functions {#Chap-01-01-functions}

### Defining your own functions

#### Named functions

#### Anonymous functions

### Some important built-in functions

#### Logical operators etc

##### Standard logic

- `&`: "and"
- `|`: "or"
- `!`: "not"
- `all`: returns true of a vector if all elements are `T`
- `any`: returns true of a vector if at least on element is `T`

##### Comparisons

- `<`: smaller
- `>`: greater
- `==`: equal (you can also use `near()`instead of `==` e.g. `near(3/3,1)`returns TRUE)
- `>=`: greater or equal
- `<=`: less or equal
- `!=`: not equal

##### Set theory


## Loops and maps {#ch-01-01-loops-and-maps}

- `for` loops
- functional programming with `apply` `purrr`
  - the philosophy of "passing functions to functions"
- piping

## Rmarkdown

