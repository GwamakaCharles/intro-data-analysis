# Basics of R {#Chap-01-01-R}

R is a specialized programming language for data science. Though old, it is heavily supported by an active community. New tools for data handling, visualization, and statistical analysis are provided in the form of **packages**.^[Packages live in the official package repository [CRAN](https://cran.r-project.org/), or are supplied in less standardized forms, e.g., via open repositories, such as GitHub.] While other programming languages specialized for scientific computing, like Python of Julia, also lend themselves beautifully for data analysis, the choice of R in this course is motivated because R's raison d'Ãªtre is data analysis. Some of the R packages that this course will use provide cutting-edge methods which are not as conveniently available in other programming languages (yet).

In a manner of speaking, there are two flavors of R. We should distinguish **base R** from the **tidyverse**. Base R is what you have when you do not load any packages. We enter the tidyverse by loading the package `tidyverse` (see below for information on how to do that). The tidyverse consists of several components (which are actually stand-alone packages that can be loaded separately if needed) all of which supply extra functionality for data analysis, based on a unifying philosophy and representation format. While eventually interchangable, the look-and-feel of base R and the tidyverse is quite different. Figure \@ref(fig:01-00-tidyverse-overview) lists a selection of packages from the tidyverse in relation to their role at different stages of the process of data analysis. The image is taken from [this introduction to the tidyverse](https://rviews.rstudio.com/2017/06/08/what-is-the-tidyverse/).


```{r 01-00-tidyverse-overview, echo = F, fig.cap="Overview of selected packages from the tidyverse."}
knitr::include_graphics("visuals/tidyverse_overview.png")
```

The course will also introduce [Rmarkdown](https://rmarkdown.rstudio.com/articles_intro.html) in Section \@ref(ch-01-01-Rmarkdown). Rmarkdown is a nice way of documenting your data analyes in a reproducible form. Participants  will use Rmarkdown to prepare their homework assignments.

Make sure to have completely installed everything of relevance for this course, as described in Section \@ref(Chap-01-00-intro-installation). Unless you have strong opinions or an unassailable favorite, we recommend trying [RStudio](https://rstudio.com) as an IDE for R.

The official documentation for base R is [An Introduction to R](https://colinfay.me/intro-to-r/). The standard reference for using the tidyverse is [R for Data Science (R4DS)](https://r4ds.had.co.nz). There are some very useful [cheat sheets](https://rstudio.com/resources/cheatsheets/) which you should definitely check out! There are pointers to further material in Appendix \@ref(app-90-02-reading-material).

```{block, type='infobox'}
The learning goals for this chapter are:

- become familiar with R, its syntax and basic notions
- become familiar with the key functionality from the tidyverse
- understand and write simple R scripts
- be able to write documents in Rmarkdown
```


## First steps {#ch1-first-steps}

R is an interpreted language. This means that you do not have to compile it. You can just evaluate it line by line, in a so-called **session**. The session stores the current values of all variables. If you do not want to retype, you can store your code in a **script**.^[Line-by-line execution of code is useful for quick development and debugging. Make sure to learn about keyboard shortcuts to execute single lines or chunks of code in your favorite editor, e.g., check the [RStudio Cheat Sheet](https://rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf) for information on its keyboard shortcuts.]

Try this out by either typing `r` to open an R session in a terminal or load RStudio.^[When starting a session in a terminal, you can exit a running R session by typing `quit()` or `q()`.] You can immediately calculate stuff:

```{r}
6 * 7
```

### Functions

R has many built-in functions. The most common situation is that the function is called by its name using **prefix notation**, followed by round brackets which enclose the function's arguments (separated by commata if multiple). For example, the function `round` takes a number and, per default, returns the closest integer:

```{r}
## the function `round` takes a number as argument and 
## returns the closest integer (default)
round(0.6)
```

Actually, `round` allows several arguments. It takes as input the number `x` to be rounded, and another integer number `digits` which gives the number of digits after the comma to which `x` should be rounded. We can then specify these arguments in a function call of `round` by providing the named arguments.

```{r}
## rounds the number `x` to the number `digits` of digits
round(x = 0.138, digits = 2)
```

When providing all arguments with names, the order of arguments does not matter. When providing at least one non-named argument, all non-named arguments have to be presented in the right order (as expected by the function; to find out what that is use `help`, as explained below in \@ref(Chap-01-01-R-help)) after subtracting the named arguments from the ordered list of arguments.

<!-- EXERCISE: validate what's written here with a function that takes at least three named arguments -->

```{r, eval = FALSE}
round(x = 0.138, digits = 2)  # works as intended
round(digits = 2, x = 0.138)  # works as intended
round(0.138, digits = 2)      # works as intended
round(0.138, 2)               # works as intended
round(x = 0.138, 2)           # works as intended
round(digits = 2, 0.138)      # works as intended
round(2, x = 0.138)           # works as intended
round(2, 0.138)               # does not work as intended (returns 2)
```

Functions can have default values for some or all of their arguments. In the case of `round` the default is `digits = 0`. There is obviously no default for `x` in the function `round`.

Some functions can take an arbitrary number of arguments. The function `sum`, which sums up numbers is a point in case.

```{r}
## adds all of its arguments together
sum(1,2,3)
```

Selected functions can also be called in **infix notation**. This applies to frequently recurring operations, such as mathematical operations or logical comparisons.

```{r, eval = F}
## both of these calls sum 1, 2, and 3 together
sum(1,2,3)     # prefix notation
1 + 2 + 3      # prefix notation
```

Section \@ref(Chap-01-01-functions) will list some of the most important built-in functions. It will also explain how to define your own functions.

### Variables

You can assign values to variables using three assignment operators: `->`, `<-` and `=`, like so:

```{r}
x <- 6
7 -> y
z = 3
x * y / z
```

Use of `=` is discouraged.^[You can produce `<-` in RStudio with Option-`-` (on Mac) and Alt-`-` (on Windows/Linux). For other useful keyboard shortcuts, see [here](https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts).]

It is good practice to use a consistent naming scheme for variables. This book uses `snake_case_variable_names` and tends towards using `long_and_excessively_informative_names` for important variables, and short variable names, like `i`, `j` or `x`, for local variables, indices etc.


### Literate coding

It is good practice to document code with short but informative comments. Comments in R are demarcated with `#`.

```{r}
x <- 4711 # a nice number from Cologne
```

Since everything on a line after an occurrence of `#` is treated as a comment, it is possible to break long function calls across several lines, and to add comments to each line:

```{r, eval = F}
round(            # call the function `round`
  x = 0.138,      # number to be rounded
  digits = 2      # number of after-comma digits to round to
)  
```


In RStudio, you can use `Command+Shift+C` (on Mac) and `Ctrl+Shift+C` (on Windows/Linux) to comment or uncomment code, and you can use comments to structure your scripts. Any comment followed by `----` is treated as a (foldable) section.

```{r, eval = FALSE}
# SECTION: variable assignments ----
x <- 6
y <- 7
# SECTION: some calculations ----
x * y
```

### Objects

Strictly speaking, all entities in R are *objects* but that is not always apparent or important for everyday practical purposes [see the manual for more information](https://colinfay.me/intro-to-r/objects-their-modes-and-attributes.html). R supports an object-oriented programming style, but we will not make (explicit) use of this functionality. In fact, this course heavily uses and encourages a functional programming style (see Section \@ref(ch-01-01-loops-and-maps)).

Some functions (e.g., optimizers or fitting functions for statistical models) return objects, however, and we will use this output in various ways. For example, if we run a linear regression model on some data set, the output is an object.

```{r}
## you do not need to understand this code
model_fit = lm(formula = speed~dist, data = cars)
## just notice that the function `lm` returns an object
is.object(model_fit)
## printing an object on the screen usually gives you summary information
print(model_fit)
```

### Packages

Much of R's charm unfolds through the use of packages. [CRAN](https://cran.r-project.org) has the official package repository. To install a new package from a CRAN mirror use the `install.packages` function. For example, to install the package `devtools`, you would use:

```{r, eval = FALSE}
install.packages("devtools")
```

Once installed, you need to load your desired packages for each fresh session, using:

```{r, eval = FALSE}
library(devtools)
```

Once loaded all functions, data etc. that ship with a package are available without additional reference to the package name. If you want to be careful or curteous to an admirer of your code, you can reference the package a function comes from explicitly. For example, the following code calls the function `install_github` from the package `devtools` explicitly (so that you would not need to load the package beforehand, for example):

```{r, eval = F}
devtools::install_github("SOME-URL")
```

Indeed, the `install_github` function allows you to install bleeding-edge packages from github. You can install all of the relevant packages using (after installing the `devtools` package, as described in Section \@ref(Chap-01-00-intro-installation):

```{r, eval = F}
devtools::install_github("n-kall/IDA2019-package")
```

After this installation, you can load all packages for this course simply by using:

```{r, eval = FALSE}
library(IDA2019)
```

In RStudio, there is a special tab in the pane with informtion on "files", "plots" etc. to show all installed packages. This also shows which packages are currently loaded.


### Getting help {#Chap-01-01-R-help}

If you encounter a function like `lm` that you do not know about, you can access its documentation with the `help` function or just typing `?lm`. Ror example, the following call summons the documentation for `lm`, the first parts are shown in Figure \@ref(fig:R-doc-example).

```{r, eval = FALSE}
help(lm)
```

```{r R-doc-example, fig.cap = "Excerpt from the documentation of the `lm` function."}
knitr::include_graphics("visuals/R-doc-example.png")
```

If you are looking for help on a more general topic, use the function `help.search`. It takes a regular expression as input and outputs a list of occurrences in the available documentation. A useful shortcut for `help.search` is just to type `??` followed by the (unquoted) string to search for. For example, calling either of the following lines might produce a display like in Figure \@ref(fig:R-doc-search-example).

```{r, eval = FALSE}
## two equivalent ways for obtaining help on search term 'linear'
help.search("linear")
??linear
```


```{r R-doc-search-example, fig.cap = "Result of calling `help.search` for the term 'linear'."}
knitr::include_graphics("visuals/R-doc-search-example.png")
```

The top entries in Figure \@ref(fig:R-doc-search-example) are **vignettes**. These are compact manuals or tutorial on particular topics or functions, and they are directly available in R. If you want to browse through the vignettes available on your machine (which depend on which packages you have installed), go ahead:

```{r, eval = FALSE}
browseVignettes()
```


## Data types {#ch1-data-types}

Let's briefly go through the data types that are most important for our later purposes. We can assess the type of an object stored in variable `x` with the function `typeof(x)`. 

```{r, eval = F}
typeof(3)        ## returns type "double"
typeof(TRUE)     ## returns type "logical"
typeof(cars)     ## returns 'list' (includes data.frames, tibbles, objects, ...)
typeof("huhu")   ## return 'character" (= string) 
typeof(mean)     ## return 'closure" (= function)
typeof(c)        ## return 'builtin" (= deep system internal stuff)
typeof(round)    ## returns type "special" (= well, special stuff?)
```

To learn more about an object, it can help to just print it out as a string:

```{r}
str(lm)
```


It is sometimes possible to cast objects of one type into another type `XXX` using functions `as.XXX` in base R or `as_XXX` in the tidyverse.

```{r}
## casting Boolean value `TRUE` into number format 
as.numeric(TRUE)
```

R is essentially an array-based language. Arrays are arbitrary but finite dimensional matrices. We will discuss what is usually referred to as vectors (= one-dimensional arrays), matrices (= two-dimensional arrays) and arrays (= more-than-two-dimensional) in the following section on numeric information. But it is important to keep in mind that arrays can contain objects of other types than numeric information (as long as all objects in the array are of the same type).

### Numeric vectors & matrices

#### Numeric information

Standard number format in R is double. 

```{r}
typeof(3)
```

We can also represent numbers as integers and complex.

```{r}
typeof(as.integer(3))    # returns 'integer'
typeof(as.complex(3))    # returns 'complex'
```

#### Numeric vectors

As a generally useful heuristic, expect every numerical information to be treated as a vector (or higher-order: matrix, array, ... ; see below), and to expect any (basic, mathematical) operation in R to (most likely) apply to the whole vector, matrix, array, collection.^[If you are familiar with Python's *scipy* and *numpy* packages, this is R's default mode of treating numerical information.] This makes it possible to ask for the length of a variable to which we assing a single number, for instance:

```{r}
x <- 7
length(x)
```

We can even index such a variable:

```{r}
x <- 7
x[1]     ## what is the entry in position 1 of the vector x?
```

Or assign a new value to a hitherto unused index:

```{r}
x[3] <- 6   ## assign the value 6 to the 3rd entry of vector x
x           ## notice that the 2nd entry is undefined, or "NA", not available
```

Vectors in general can be declared with the built-in function `c()`. To memorize this, think of *concatenation* or *combination*.

```{r}
x <- c(4, 7, 1, 1)   # this is now a 4-place vector
x
```

There are also helpful functions to generate sequences of numbers:

```{r, eval = F}
1:10                                     ## returns 1, 2, 3, ..., 10
seq(from = 1, to = 10, by = 1)           ## returns 1, 2, 3, ..., 10
seq(from = 1, to = 10, by = 0.5)         ## returns 1, 1.5, 2, ..., 9.5, 10
seq(from = 0, to = 1 , length.out = 11)  ## returns 0, 0.1, ..., 0.9, 1
```

Indexing in R starts with 1, not 0!

```{r}
x <- c(4, 7, 1, 1)   # this is now a 4-place vector
x[2]
```

And now we see what is meant above when we said that (almost) every mathematical operation can be expected to apply to a vector:

```{r}
x <- c(4, 7, 1, 1)   # 4-placed vector as before
x + 1
```

#### Numeric matrices

Matrices are declared with the function `matrix`. This function takes, for instance, a vector as an argument.

```{r}
x <- c(4, 7, 1, 1)     # 4-placed vector as before
(m <- matrix(x))       # cast x into matrix format
```

Notice that the result is a matrix with a single column. This is important. R uses so-called *column-major mode*.^[Python, on the other hand, uses the reverse *row-major mode*.] This means that it will fill columns first. For example, a matrix with three columns based on a six-placed vector $1, 2, \dots, 6$ will be built by filling the first column from top to bottom, then the second column top to bottom, and so on.^[It is in this sense that the "first index moves fastest" in column-major mode, which is another frequently given explanation of column-major mode.]

```{r}
m <- matrix(1:6, ncol = 3)
m
```

In line with column-major mode, vectors are treated as column vectors in matrix operations:

```{r}
x = c(1,0,1)   ## 3-place vector
m %*% x        ## dot product with previous matrix 'm'
```

As usual, and independently of column- or row-major mode, matrix indexing starts with the row index:

```{r}
m[1,]   ## produces first row of matrix 'm'
```

#### Arrays

Arrays are simply higher-dimensional matrices. We will not make use of arrays in this course.

#### Names for vectors, matrices and arrays

The positions in a vector can be given names. This is extremely useful for good "literate coding" and therefore highly recommended. The names of vector `x`'s positions are retrieved and set by the `names` function:

```{r}
students <- c("Jax", "Jamie", "Jason")  # names of students
grades <- c(1.3, 2.7, 2.0)              # a vector of grades
names(grades)                           # retrieve names: with no nanmes so far
names(grades) <- students               # assign names
names(grades)                           # retrieve names again: names assigned
grades                                  # output shows names
```

We can also set the names of a vector directly during construction:^[Notice that we can create strings (actually called 'characters' in R) with double quotes]

```{r}
## names of students (this is a character vector, see below)
students <- c("Jax", "Jamie", "Jason")  
## constructing a vector with names directly assigned
grades <- c(1.3, 2.7, 2.0, names = students) 
```


Names for matrices are retrieved or set with functions `rownames` and `colnames`.

```{r}
## declare matrix
m <- matrix(1:6, ncol = 3)  
## assign row and column names, using function
## `str_c` which is described below
rownames(m) <- str_c("row", 1:nrow(m), sep = "_")
colnames(m) <- str_c("col", 1:ncol(m), sep = "_")
m
```

### Booleans

There are built-in names for Boolean values "true" and "false", predictably named `TRUE` and `FALSE`. Equivalent shortcuts are `T` and `F`. If we attempt to do math with Boolean vectors, the outcome is what any reasonable logician would expect:

```{r}
x = c(T,F,T)
1 - x
x + 3
```

Boolean vectors can be used as index sets to extract elements from other vectors.

```{r}
# vector 1, 2, ..., 5
number_vector  = 1:5           
# index of odd numbers set to `TRUE`
boolean_vector = c(T,F,T,F,T)  
## returns the elemnts from number vector, for which
## the corresponding element in the Boolean vector is true
number_vector[boolean_vector] 
```

### Special values

There are a couple of keywords reserved in R for special kinds of objects:

- `NA`: "not availables"; represents missing values in data
- `NaN`: "not a number"; e.g., division zero by zero
- `Inf` or `-Inf`: infinity and negative infinity; returned when number is too big or devision by zero
- `NULL`: the NULL object; often returned when function is undefined for input

### Characters (= strings)

Strings are called characters in R. We will be stubborn and call them strings for most of the time here. We can assign a string value to a variable by putting the string in double quotes:

```{r}
x <- "huhu"
typeof(x)
```

We can create vectors of characters in the obvious way:

```{r}
chr_vector = c("huhu", "hello", "huhu", "ciao")
chr_vector
```


The package `stringr` from the tidyverse also provides very useful and, in comparison to base R, more uniform functions for string manipulation. The [cheat sheet](http://edrub.in/CheatSheets/cheatSheetStringr.pdf) for the `stingr` package is highly recommended for a quick overview. Below are some examples.

Function `str_c` concatenates strings:

```{r}
str_c("Hello", "Hi", "Hey", sep = "! ")
```

We can find the indeces of matches in a character vector with `str_which`: 

```{r}
chr_vector = c("huhu", "hello", "huhu", "ciao")
str_which(chr_vector, "hu")
```

Similarly, `str_detect` gives a Boolean vector of matching:

```{r}
chr_vector = c("huhu", "hello", "huhu", "ciao")
str_detect(chr_vector, "hu")
```

If we want to get the strings matching a pattern, we can use `str_subset`:

```{r}
chr_vector = c("huhu", "hello", "huhu", "ciao")
str_subset(chr_vector, "hu")
```

Replacing all matches with another string works with `str_replace_all`:

```{r}
chr_vector = c("huhu", "hello", "huhu", "ciao")
str_replace_all(chr_vector, "h", "B")
```

For data preparation we often need to split strings by a particular character. For instance, a set of reaction times could be separated by a character line "|". We can split this string representation to get individual measurements like so:

```{r}
## three measures of reaction time in a single string
reaction_times = "123|234|345"
## notice that we need to doubly (!) escape character |
## notice also that the results is a list (see below)
str_split(reaction_times, "\\|", n = 3)
```


### Factors

- factors track levels

```{r}
factor(chr_vector)
```

- ordered factors arrange their levels

```{r}
factor(chr_vector, ordered = T,
       levels = c("huhu", "ciao", "hello"))
```

### Lists, data frames & tibbles

- lists are key-value pairs

```{r}
my_list = list(dudu = 1,
               chacha = c("huhu", "ciao"))
```

- data frames as lists of same-length vectors

```{r}
exp_data = data.frame(
  trial = 1:5,
  condition = factor(c("C1", "C2", "C1", "C3", "C2"),
                     ordered = T),
              response = c(121, 133, 119, 102, 156))
exp_data
```

- access columns

```{r}
exp_data$condition
```

- access rows

```{r}
exp_data[3,]
```

- tibbles are data frames in the tidyverse

```{r}
as_tibble(exp_data)
```

- tibbles do but data frames don't allow for dynamic construction:

- some differences

```{r, eval = FALSE}
my_tibble    = tibble(x = 1:10, y = x^2)      ## dynamic construction possible
my_dataframe = data.frame(x = 1:10, y = x^2)  ## ERROR :/
```

## Functions {#Chap-01-01-functions}

Many helpful functions are defined in base R or supplied by packages. If you find yourself in a situation in which you would like to copy-paste some code, possibly with minor amendments, this usually means that you should wrap some recurring operations into a custom-defined function.

### Defining your own functions

There are two ways of defining your own functions: as a named function, or an anonymous function.

#### Named functions

The special operator supplied by base R to create new functions is the keyword `function`. Here is an example of defining a new function with two input variables `x` and `y` that returns a computation based on these numbers. We assign this newly created function to the variable `cool_function`, so that we can use this name to call the function later.

```{r, eval = F}
## define a new function
## takes two numbers x & y as argument
## returnt x * y + 1
cool_function = function(x, y) {
  return(x * y + 1)   ## `return` is optional; w/o it the last line's evaluation is returned
}

## apply `cool_function` to some numbers:
cool_function(3,3)     ## return 10
cool_function(1,1)     ## return 2
cool_function(1:2,1)   ## returns vector [2,3]
cool_function(1)       ## throws error: 'argument "y" is missing, with no default'
cool_function()        ## throws error: 'argument "x" is missing, with no default'

```

We can give default values for the parameters passed to a function:

```{r, eval = F}
## define a new function
## takes two numbers x & y as argument
## assigns a default values to each argument
## returnt x * y + 1
cool_function_2 = function(x = 2, y = 3) {
  return(x * y + 1)
}

## apply `cool_function_2` to some numbers:
cool_function_2(3,3)     ## return 10
cool_function_2(1,1)     ## return 2
cool_function_2(1:2,1)   ## returns vector [2,3]
cool_function_2(1)       ## returns 4 (= 1 * 3 + 1)
cool_function_2()        ## returns 7 (= 2 * 3 + 1)
```

#### Anonymous functions

Notice that we can feed functions as parameters to other functions. This is an important ingredient of a functional-stlye of programming, and something that we will rely on heavily in this course (see Section \@(ch-01-01-loops-and-maps)). When supplying a function as an argument to another function, we might not want to name the function that is passed. Here's a (stupid, but hopefully illustrating) example:

```{r, eval = F}
## define a function that takes a function as argument
new_applier_function = function(input, function_to_apply) {
  return(function_to_apply(input))
}

## sum vector with built-in & named function
new_applier_function(
  input = 1:2,              # input vector 
  function_to_apply = sum   # built-in & named function to apply
)   ## returns 3

## sum vector with anonymous function
new_applier_function(
  input = 1:2,              # input vector 
  function_to_apply = function(input) {
    return(input[1] + input[2])
  } 
)   ## returns 3 as well
```


### Some important built-in functions

There are many useful built-in functions. We recommend browsing the [Cheat Sheets](https://rstudio.com/resources/cheatsheets/) every now and then to pick up more useful stuff for your inventory.

#### Logical operators etc

##### Standard logic

- `&`: "and"
- `|`: "or"
- `!`: "not"
- `all`: returns true of a vector if all elements are `T`
- `any`: returns true of a vector if at least on element is `T`

##### Comparisons

- `<`: smaller
- `>`: greater
- `==`: equal (you can also use `near()`instead of `==` e.g. `near(3/3,1)`returns TRUE)
- `>=`: greater or equal
- `<=`: less or equal
- `!=`: not equal

##### Set theory

- `%in%`: wheter an element is in a vector
- `union(x,y)`: union of `x` and `y`
- `intersect(x,y)`: intersection of `x` and `y`
- `setdiff(x,y)`: all elements in `x` that are not in `y`

##### Sampling and combinatorics

- `runif()`: random numer from unit interval [0;1]
- `sample(x, size, replace)`: take `size` samples from `x` (with replacement is `replace` is `T`)
- `choose(n,k)`: number of subsets of size `n` out of a set of size `k` (binomial coefficient) 

## Loops and maps {#ch-01-01-loops-and-maps}



- `for` loops
- functional programming with `apply` `purrr`
  - the philosophy of "passing functions to functions"
- piping

## Rmarkdown {#ch-01-01-Rmarkdown}

Howework assignments will be issued, filled and submitted in Rmarkdown. To get familiar with Rmarkdown, please follow this [tutorial](https://rmarkdown.rstudio.com/articles_intro.html).
